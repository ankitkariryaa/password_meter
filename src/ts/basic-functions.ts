import Dictionaries = require("./dict-misc");
import Helper = require("./helper");
// import JQuery = require("jquery");
import LZString = require("lz-string");
import PasswordMeter = require("./PasswordMeter");
import Config = require("./config");
import RuleFunctions = require("./rulefunctions");

export module BasicFunctionality {
	export class BasicFunctionality {
		helper: Helper.Helper.Helper;
		// $: JQueryStatic;
		verboseMode: boolean;
    // Previously computed information about password scores and feedback
		// To avoid scoring things multiple times, store mappings in associative arrays
		// -1 means that we already spawned a thread to perform this calculation, so don't duplicate it
		// Mapping of passwords to score based on advanced heuristics
		private heuristicMapping: {[key: string]: number} = {};
		// Mapping of passwords to score based on neural networks
		private neuralnetMapping: {[key: string]: number} = {};
    // Mapping of passwords to public/sensitive feedback
    // potentialTODO that could get expensivex
    // potentialTODO structure this
    private feedbackMapping: {[key: string]: string} = {};


    constructor(verboseMode: boolean) {
			var registry = PasswordMeter.PasswordMeter.instance;
			this.helper = registry.getHelper();
			// this.$ = registry.getJquery();
			this.verboseMode = verboseMode;
		}

    randomNumber(): string{
      return('saddf');
    }
    setNeuralnetMapping(pw: string, value: number): void {
      this.neuralnetMapping[pw] = value;
    }

    // A function used to avoid showing redundant text feedback
    // generated by different scoring functions.
    // Returns true (redundant with previous feedback) or false (not redundant).
    redundant(problemText: string, arrayOfProblems: Array<string>): boolean {
      // Lowercase since some rule functions lowercase feedback
      problemText = problemText.toLowerCase();
      for (var i = 0; i < arrayOfProblems.length; i++) {
        arrayOfProblems[i] = arrayOfProblems[i].toLowerCase();
        if (arrayOfProblems[i].length > 0 && problemText.length > 0) {
          if ((arrayOfProblems[i].indexOf(problemText) >= 0
            && problemText.length >= 0.7 * arrayOfProblems[i].length)
            || (problemText.indexOf(arrayOfProblems[i]) >= 0
              && arrayOfProblems[i].length >= 0.7 * problemText.length)) {
            return true;
          }
        }
      }
      return false;
    }

    showNNRating(pw:string):number {
      for (var i = 1; i < 1000000; i++) {
      }
      return(this.neuralnetMapping[pw])
    }

    queryHeuristicGuessNumber(pw: string, username: string, primaryPassword: boolean): number {
      var nni = PasswordMeter.PasswordMeter.instance.getNN();
			var nn = nni.nn;
      if (typeof (this.neuralnetMapping[pw]) === "undefined") {
				// Signal that we are calculating it to avoid duplicate work
				this.neuralnetMapping[pw] = -1;
				// Asynchronously calculate neural network guess number
				nn.query_guess_number(pw);
			}
			// Used to make 10^{15} fill 2/3rds of the bar
			var scalingFactor = 67 / 15;
			// We overwrite the password if they use contextual or blacklisted content
			// and we need the original to make the correct mappings
			var originalPW = pw;
			var publictips: Array<string> = [];
			var sensitivetips: Array<string> = [];
			var reasonWhy: Array<string> = [];
			var problemText: Array<string> = [];

			// Return JSON objects from all of the rule functions
			var contextualObj = RuleFunctions.RuleFunctions.contextual(pw, [username]);
			pw = contextualObj.remaining;
			// If their whole password is contextual, we hit a type error
			if (typeof (pw) === "undefined") {
				pw = "";
			}
			var blacklistObj = RuleFunctions.RuleFunctions.blacklist(pw);
			pw = blacklistObj.remaining;
			// If their whole password is blacklisted, we hit a type error
			if (typeof (pw) === "undefined") {
				pw = "";
			}

			var lenObj = RuleFunctions.RuleFunctions.pwLength(pw);
			var classObj = RuleFunctions.RuleFunctions.characterClasses(pw);
			var duplicatedObj = RuleFunctions.RuleFunctions.duplicatedCharacters(pw);
			var repeatObj = RuleFunctions.RuleFunctions.repeats(pw);
			var patternsObj = RuleFunctions.RuleFunctions.keyboardPatterns(pw);
			var sequenceObj = RuleFunctions.RuleFunctions.repeatedSections(pw);
			var structureObj = RuleFunctions.RuleFunctions.structurePredictable(pw);
			var upperPredictableObj = RuleFunctions.RuleFunctions.uppercasePredictable(pw);
			var digitsPredictableObj = RuleFunctions.RuleFunctions.digitsPredictable(pw);
			var symbolsPredictableObj = RuleFunctions.RuleFunctions.symbolsPredictable(pw);
			var upperObj = RuleFunctions.RuleFunctions.countUC(pw);
			var lowerObj = RuleFunctions.RuleFunctions.countLC(pw);
			var digitObj = RuleFunctions.RuleFunctions.countDIGS(pw);
			var symbolObj = RuleFunctions.RuleFunctions.countSYMS(pw);
			var dateObj = RuleFunctions.RuleFunctions.identifyDates(pw);
			var minimumObj = RuleFunctions.RuleFunctions.verifyMinimumRequirements(pw, username);
			var alphabeticsequenceObj = RuleFunctions.RuleFunctions.alphabeticSequenceCheck(pw);
			var commonsubstringObj = RuleFunctions.RuleFunctions.commonSubstringCheck(pw);
			var dictionaryCheckObj = RuleFunctions.RuleFunctions.combinedDictCheck(pw);
			var substringArrayNoFilter = pw.listSubstringsNoFilter(4);
			var commonpwObj = RuleFunctions.RuleFunctions.commonPwCheck(substringArrayNoFilter);
			// Take the coefficients from our regression
			var coefficients = [1.530, 0.3129, 0.9912, 0.04637, -0.03885, -0.1172, -0.2976, -0.0008581, -0.3008, -0.5566, 0, 0.9108, 0.7369, 0.7578, 0, -0.1213, -0.2402, -0.1364, -0.5534, 1.927, 0.001496, -0.3946];
			var subscores: Array<number> = [1, lenObj.length, classObj.count, duplicatedObj.count,
				repeatObj.count, patternsObj.score, sequenceObj.count, structureObj.score,
				upperPredictableObj.score, digitsPredictableObj.score, symbolsPredictableObj.score,
				upperObj.count, lowerObj.count, digitObj.count, symbolObj.count, dateObj.count,
				alphabeticsequenceObj.count, commonsubstringObj.count, dictionaryCheckObj.length,
				dictionaryCheckObj.dictionaryTokens, dictionaryCheckObj.substitutionCommonness,
				commonpwObj.length];
			// The first value is the intercept
			var overallScore = coefficients[0];
			// Take the remaining coefficients and multiply by the rule function score
			for (var i = 1; i < coefficients.length; i++) {
				overallScore += coefficients[i] * subscores[i];
			}
			overallScore = overallScore * scalingFactor;
			if (overallScore < (pw.length / 2)) {
				overallScore = pw.length / 2;
			} else if (overallScore > 100) {
				overallScore = 100;
			}
      // Save non-empty text feedback from the rule functions
			if (contextualObj.publicText.length > 0) {
				publictips.push(contextualObj.publicText);
				sensitivetips.push(contextualObj.sensitiveText);
				reasonWhy.push(contextualObj.reasonWhy);
				problemText.push(contextualObj.problemText);
			}
			if (blacklistObj.publicText.length > 0) {
				publictips.push(blacklistObj.publicText);
				sensitivetips.push(blacklistObj.sensitiveText);
				reasonWhy.push(blacklistObj.reasonWhy);
				problemText.push(blacklistObj.problemText);
			}
			if (dictionaryCheckObj.publicText.length > 0
				&& !this.redundant(dictionaryCheckObj.problemText, problemText)) {
				publictips.push(dictionaryCheckObj.publicText);
				sensitivetips.push(dictionaryCheckObj.sensitiveText);
				reasonWhy.push(dictionaryCheckObj.reasonWhy);
				problemText.push(dictionaryCheckObj.problemText);
			}
			if (patternsObj.publicText.length > 0) {
				publictips.push(patternsObj.publicText);
				sensitivetips.push(patternsObj.sensitiveText);
				reasonWhy.push(patternsObj.reasonWhy);
				problemText.push(patternsObj.problemText);
			}
			if (repeatObj.publicText.length > 0) {
				publictips.push(repeatObj.publicText);
				sensitivetips.push(repeatObj.sensitiveText);
				reasonWhy.push(repeatObj.reasonWhy);
				problemText.push(repeatObj.problemText);
			}
			if (dateObj.publicText.length > 0) {
				publictips.push(dateObj.publicText);
				sensitivetips.push(dateObj.sensitiveText);
				reasonWhy.push(dateObj.reasonWhy);
				problemText.push(dateObj.problemText);
			}
			if (sequenceObj.publicText.length > 0) {
				publictips.push(sequenceObj.publicText);
				sensitivetips.push(sequenceObj.sensitiveText);
				reasonWhy.push(sequenceObj.reasonWhy);
				problemText.push(sequenceObj.problemText);
			}
			if (alphabeticsequenceObj.publicText.length > 0) {
				publictips.push(alphabeticsequenceObj.publicText);
				sensitivetips.push(alphabeticsequenceObj.sensitiveText);
				reasonWhy.push(alphabeticsequenceObj.reasonWhy);
				problemText.push(alphabeticsequenceObj.problemText);
			}
			if (commonpwObj.publicText.length > 0 && !this.redundant(commonpwObj.problemText, problemText)) {
				publictips.push(commonpwObj.publicText);
				sensitivetips.push(commonpwObj.sensitiveText);
				reasonWhy.push(commonpwObj.reasonWhy);
				problemText.push(commonpwObj.problemText);
			}
			if (upperPredictableObj.publicText.length > 0) {
				publictips.push(upperPredictableObj.publicText);
				sensitivetips.push(upperPredictableObj.sensitiveText);
				reasonWhy.push(upperPredictableObj.reasonWhy);
				problemText.push(upperPredictableObj.problemText);
			}
			if (digitsPredictableObj.publicText.length > 0) {
				publictips.push(digitsPredictableObj.publicText);
				sensitivetips.push(digitsPredictableObj.sensitiveText);
				reasonWhy.push(digitsPredictableObj.reasonWhy);
				problemText.push(digitsPredictableObj.problemText);
			}
			if (symbolsPredictableObj.publicText.length > 0) {
				publictips.push(symbolsPredictableObj.publicText);
				sensitivetips.push(symbolsPredictableObj.sensitiveText);
				reasonWhy.push(symbolsPredictableObj.reasonWhy);
				problemText.push(symbolsPredictableObj.problemText);
			}
			if (duplicatedObj.publicText.length > 0) {
				publictips.push(duplicatedObj.publicText);
				sensitivetips.push(duplicatedObj.sensitiveText);
				reasonWhy.push(duplicatedObj.reasonWhy);
				problemText.push(duplicatedObj.problemText);
			}
			if (lenObj.publicText.length > 0) {
				publictips.push(lenObj.publicText);
				sensitivetips.push(lenObj.sensitiveText);
				reasonWhy.push(lenObj.reasonWhy);
				//problemText.push(lenObj.problemText);
			}
			if (symbolObj.publicText.length > 0) {
				publictips.push(symbolObj.publicText);
				sensitivetips.push(symbolObj.sensitiveText);
				reasonWhy.push(symbolObj.reasonWhy);
				//problemText.push(symbolObj.problemText);
			}
			if (upperObj.publicText.length > 0) {
				publictips.push(upperObj.publicText);
				sensitivetips.push(upperObj.sensitiveText);
				reasonWhy.push(upperObj.reasonWhy);
				//problemText.push(upperObj.problemText);
			}
			if (digitObj.publicText.length > 0) {
				publictips.push(digitObj.publicText);
				sensitivetips.push(digitObj.sensitiveText);
				reasonWhy.push(digitObj.reasonWhy);
				//problemText.push(digitObj.problemText);
			}
			if (lowerObj.publicText.length > 0) {
				publictips.push(lowerObj.publicText);
				sensitivetips.push(lowerObj.sensitiveText);
				reasonWhy.push(lowerObj.reasonWhy);
				//problemText.push(lowerObj.problemText);
			}
			if (commonsubstringObj.publicText.length > 0 && !this.redundant(commonsubstringObj.problemText, problemText)) {
				publictips.push(commonsubstringObj.publicText);
				sensitivetips.push(commonsubstringObj.sensitiveText);
				reasonWhy.push(commonsubstringObj.reasonWhy);
				//problemText.push(commonsubstringObj.problemText);
			}
			if (structureObj.publicText.length > 0) {
				publictips.push(structureObj.publicText);
				sensitivetips.push(structureObj.sensitiveText);
				reasonWhy.push(structureObj.reasonWhy);
				//problemText.push(structureObj.problemText);
			}

      var feedback = JSON.stringify({
				publictips1: publictips[0],
				publictips2: publictips[1],
				publictips3: publictips[2],
				sensitivetips1: sensitivetips[0],
				sensitivetips2: sensitivetips[1],
				sensitivetips3: sensitivetips[2],
				reasonWhy1: reasonWhy[0],
				reasonWhy2: reasonWhy[1],
				reasonWhy3: reasonWhy[2]
			});

      // Save the mapping of password to score
      this.heuristicMapping[originalPW] = overallScore;
      // Save the mapping of password to feedback
      this.feedbackMapping[originalPW] = feedback;

      console.log(feedback);
      return(overallScore);
    }
  // Update all aspects of the UI (bar and text feedback) to reflect password.
  // Note that the password score and feedback was generated + cached in other functions.
  displayRating(pw: string): void {
    var overallScore = 0;
    var numberOfScores = 0;
    if (pw.length > 0) {
      if (typeof (this.heuristicMapping[pw]) !== "undefined"
        && this.heuristicMapping[pw] >= 0) {
        overallScore = this.heuristicMapping[pw];
        numberOfScores++;
      }
      if (typeof (this.neuralnetMapping[pw]) !== "undefined"
        && this.neuralnetMapping[pw] >= 0 && isFinite(this.neuralnetMapping[pw])) {
        numberOfScores++;
        if (overallScore == 0 || (overallScore > 0
          && this.neuralnetMapping[pw] < overallScore)) {
          overallScore = this.neuralnetMapping[pw];
        }
      }
    }
    if (overallScore < pw.length / 2) {
      overallScore = pw.length / 2; // make people see at least some progess is happening
    }
    console.log(overallScore);
  }

  }
	(function() {
      var registry = PasswordMeter.PasswordMeter.instance;
      var verboseMode = false;
      var instance = new BasicFunctionality(verboseMode);
      registry.setBF(instance);
    }())

}
